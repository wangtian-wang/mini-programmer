---
typora-copy-images-to: ../image/two_thread.png
---

typora-root-url: ../image

 

# 小程序设计-双线程

>    双线程是啥

1. 渲染层
   1.  小程序渲染层可以有多个webview，多个webview被管理在一个页面栈中 界面渲染的任务全在webview线程里执行， 逻辑层控制渲染那个webview
2. 逻辑层
   1. 小程序提供了一个纯JS运行的沙箱环境。
   2. 一个小程序只有一个逻辑层，即使切换了页面，script中的非data中定义的变量还会保存在页面内存中 除非小程序被关闭
3. 总结： 一个小程序只能有一个逻辑层，渲染层里面每个webview都是一个线程

​         不同平台下的运行环境

![](/Users/wangtian/Desktop/mini-programmer/image/enviroment.png)         

> 双线程设计的原因

双线程的方武可以阻止开发者传用浏览器提供的诸如跳转页面、操作DOM、动态执行脚本的开放性接口。安全性考虑

> 优点

js 与webview运行在两个线程中 不存在阻塞问题，页面会更加流程

> 缺点

js和webview的通信需要靠native来实现 假若数据量大 会**引起性能。交互体验**等问题

> 双线程通信设计

<img src="/Users/wangtian/Desktop/mini-programmer/image/two_thred.png" alt="two_thred" style="zoom:50%;" />

> Virtual-dom------- dom_diff

<img src="/Users/wangtian/Desktop/mini-programmer/image/dom_diff.png" alt="dom_diff" style="zoom:80%;" />

> 双线程通信方式

可以通过在渲染层、逻辑层的全局对象中注入一个原生的方法用于通信，封装成 WoxinISBridge 这样一-个兼容层（有点像H5 API)开发者不需要处理差异 底层框架会对原生能力进行同一封装

> setData的调用过程

在小程序中，双线程通信时会将需要传输的数据转救为字行串形式。以逻辑层为例，逻辑层可以使用 setData API将数据同出到渲染层。下面是 setData 调用的过程。

1：  当开发者调用 setData API的时候，底层会使用 JsoN.stringiEy 处理一遍数据。不可序列化的数据将会被移除。
2： 之后，逻辑层**`会将数据发送给渲染层，还会同步更新页面中的data 数据`**，这样开发者可以在调用 setData之后，从this.data 中荻取到变更后的最新数据。
3： 显然，数据的传输需要通过 Native 进行中转，因此并不能实时地到达渲染层，所以`setData 将数据从逻辑层发送到渲染层就是异步的`。如果我们需要知道界面這染完毕，可以在调用 setData 的时候通过传人 cal1back 回调进行监听。
总结 ：  

​              1： 用户传输的数据最终以转换为字符串的形式传递，所以 setDate 仅支持可序化的数据

​              2 ：根据官方文档，单次设置的数据不能超过 1024KB（执行 JsON. stringiEy后的大小)，	

# 小程序-渲染层

渲染层模型

> shadow dom

渲染层渲染过程

> 页面渲染过程

总结 ： 因为页面WXML 的這染只需要传递 setData 的数据，然后在渲染层进行渲染、差异比较更新 。所以页面谊染流程如下。

1. 渲染层 WXML生成一个 Virtual DOM 的JS对象，拼接 Shadoree，注人初始数据进行渲染。
2. 逻辑层开始执行逻辑，调用 setData 之后，会把 setData 的数据通过 Native 传递到渲染层
3. 渲染层页面更新：渲染层对需要更新的数据进行 Dif，得到差异，然后把差异应用到真实的 DOM中，从而更新页面。

> 组件渲染过程

总结： 因为自定义组件需要用到this，所以渲染层和逻辑层都维护VirtualDOM信息

1. 逻辑层新建组件，并通知道染层：在逻辑层，首先 WXML和IS福要生成一个IS对象，JS节点部分生成 VitualDOM 信息，最后通过底层通信通知到谊染尽。渲染层拿到 VitualNode节点信息后，创建 Shadow DOM拼按 Shadow Tree， 注人初始数据渲染。
2. 逻辑层调用 setData，更新数据到渲染层：逻辑层调用 setData 之后，会在逻辑层进行 DOM Diff，然后将 Diff结果传到渲染层（注意，此处与页面的渲染流程不一致)。道染层组件更新：渲染层拿到 Diff信息，更新VirtualDOM 节点信息，同时更新页面。

> 同步队列------------逻辑层和渲染层的VitualDOM 保持一致

1. 带来的问题
   1. 频繁调用setData会带来性能上的问题。setData是逻辑层和渲染层通信的过程 如果一大堆的setData被调用，通信效率会很低。
2. 如何解决
   1. 把一次操作的所有setData整合到一次通信里，排序保证顺序。
   2. 避免每次都向setData传递大量数据。

渲染层DOM转为数据

1. ​	代码转为JS对象 模板引擎将模板语法解析成 HTMLDOM 交给浏览器渲染

2. ​    DOM元素创建		

3. ​    数据绑定更新

4.    数据更新差异对比

   1. 用Js对象模拟 DOM树。
   2. 比较两个 虚拟DOM 树的差异。当状态变更的附候，新建一个DOM数， 比较、记录两裸树的差异。
   3. 将差异应用在真正的DOM树上

   总结： 渲染层（WXML----》JS对象）

   ​            逻辑层数据变更 setData传递差异数据到渲染层

   ​			渲染层对比差异渲染正确的UI

小程序原生组件

1. 出现原因： 逻辑层渲染层交互频繁带来的性能问题

   <img src="/Users/wangtian/Desktop/mini-programmer/image/inter.png" alt="inter" style="zoom:50%;" />

1. 原生组件如何解决这个问题

2. 原生组件的渲染过程

   1. 首先，渲染层会根据逻辑层传人的数据创建该组件。
   2. 然后，该组件会被插人页面，webviovw会谊染布局，可以得组件宽和高。
   3. 最后，我將计算得到的数据告诉客户端，客户端就可以将原生组什渲染到具体的价置上，
      接下来，组件有任何交更，同样使用以上步骤来更新原生组件。

   总结 ：使用webview生成一个DOM，然后计算布局信息客户端进行渲染

   带来的问题： 原生组件的层级过高，需要正确处理页面的层级关系。

   ​                         部分css样式无法应用于原生组件、原生组件无法设置position:fixed等。

   

同层渲染

1. 出现原因
   1. 由于原生组件由客户端渲染，当和webview一起使用时，位于更高的层级 ；
   2. 多个原生组件一起使用，无法确定覆盖关系
2. 不同的平台实现
   1. iOS：
      1. 小理序在iOS 下是使用 WK WeDViow 进行渲染的。但 webKit内核已经处理了它与其他DOM 节点之同的层级关系
   2. andriod
      1. Chromium 
3. 同层渲染需要注意的点
   1. 原生组件的同层渲染能力可能会失败，失败后会触发binderndererror事件，可根据该事件进行降级
   2. 因为同层渲染是将原生组件渲染到某个webview组件上，所以有些对有些原生组件剪裁不会生效。例如 border-radius 属性。
   3. 原生组件不支持事件冒泡，但同层渲染之后的原生组件会进行事件冒泡，我们同样可以使用 catch 来阻止。

# 小程序-基础库

#### 组成

<img src="/Users/wangtian/Desktop/mini-programmer/image/base_lib.png" alt="base_lib" style="zoom:50%;" />

#### 作用

#### 启动

1. 启动过程

   ![start](/Users/wangtian/Desktop/mini-programmer/image/start.png)

2. 页面层级准备

   1. 微信提前准备好了一个webview层，当这个预备的webview层被使用后，又会创建一个新的webview层

3. 冷启动和热启动

   1. 热启动
      1. 切换到了后台，小程序的内存还在，并没有真正销毁小程序线程
   2. 冷启动
      1. 小程序在后台运行时间超过5分钟、主动删除了小程序、杀死了微信进程、小程序占用资源过高
   3. 热启动跳转/冷启动跳转 可以设置跳转到的页面

4. 首页启动优化

   1. 减少wxml结构、setData传递数据量、减少不必要的节点和数据的传输大小。

#### 更新

1. ​	小程序基础库会在微信客户端的版本更新后，再发布。
2. ​    若要强制更新当前小程序版本，可以参考开发文档 `updateManager` 

#### 代码包下载

​		冷启动下载代码包

1. 本地有缓存，本次操作使用缓存包，然后下载更新包，下次默认打开可以使用本次下载的更新包
2. 无缓存 直接下载代码包。
3. 小程序在启动时默认只会下载主包，当进入页面时才会下载对应的分包。

#### 分包加载

1. 所有分包的大小不能超过12mb
2. 单个分包不能超过2mb

####  代码包加载

1. 逻辑层appjs、首页所在的js文件以及首页中依赖的js文件都会自动执行一次。
2. 渲染层中，所有页面和页面中使用到的组件会在基础库中进行注册。

小程序的人口文件是 appjs，如果 appjis 中依赖了其他文件，则按顺序进行加载。之后小程序会根据开发者在appjison 中定义的 pages 顺序来执行对应的文件。**如果一个页面被多次创建，但是这个页面的 JavaScript文件只会执行一次，因此，即使这个页面被销毁再重新加载，页面中如果修改过全局变量的值，修改后的值依然会被保留**



# 小程序优化

